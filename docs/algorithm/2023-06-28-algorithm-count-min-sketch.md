---
layout: default
title: 'count min sketch'
parent: algorithm
nav_order: 3
date: '2023-06-28'
author: 'Young Hwang'
description: 'count min sketch'
tags: ['algorithm']
---


# 소개

안녕하세요. IMQA 개발팀에서 백엔드 영역의 개발 및 운영업무를 맡고 있는 황영 입니다.
이번 글에서는 count min sketch 라는 sketch 알고리즘에 대하여 알아보고 아직 실무에 적용하지는 않았지만
앞으로의 개선 방향에 대하여 이야기하고자 합니다.

# 빈도 계산하기

CM Sketch 는 G. Cormode 와 S. Muthukrishnan 가 2003년에 발표한 sketch 알고리즘으로 각 항목에 대한 빈도(frequency)를 표현하는 sketch 중 하나 입니다.
빈도를 계산한다고 하였는데 이건 어떤 의미인지 간단히 예를 들어 셜명하겠습니다.

```javascript
[A, B, B, N, A, R, E, A, R, A, B]
```

만약 위와 같이 데이터 스트림이 있고, 이 데이터 스트림에서 문자의 빈도를 세어야 한다고 해봅시다.
그렇다면 결과는 아래와 같을 것 입니다.

```javascript
A - 4, B - 3,  E - 1,  N - 1,  R - 2
```

# 문제점 도출

여기서 나아가 결과를 일정한 시간 간격으로 집계를 한다면 어떻게 해야될까요?
또한 이를 임의의 범위로 조회를 한다고 하면 가능할까요?

물론 위의 결과를 이용하여 n 시간 순서로 집계 및 조회 할 수 있습니다.
하지만 이러한 데이터 스트림이 계속해서 증가하며 무한하다면 어떨까요?

무한한 스트림을 처리하여 하루에 1TB의 데이터가 생성되다고 해봅시다.
한달이면 30TB의 데이터가 생성될 것입니다.

물론 30TB를 충분히 저장할수 있는 공간이 있을 수도 있습니다.
하지만 이러한 공간은 무한하지 않으며 우리는 제한된 공간과 시간, 비용을 고려하여야 합니다.
시스템에서 한달간의 데이터의 빈도를 계산이 필요 하다면 우리는 30TB의 데이터를 이용하여 계산하여야 합니다.
이는 우리가 결과를 도출하기에 많은 시간이 걸릴 수 있습니다.
하지만 시스템은 많은 시간을 할당할 수 없기에 제한되 시간내에 결과를 도출하여야 합니다.

# IMQA 에서의 고민 사항

이러한 조회 범위에 따른 공간과 시간제약 문제는 저희 IMQA에서도 격고 있는 사항입니다.

![count-min-sketch-02.png](https://young-hwang.github.io/docs/algorithm/images/count-min-sketch-02.png)

위의 이미지는 통계 > 구간분석 화면에서 '네이티브 응답속도'를 표현한 히트맵 차트 입니다.
시간의 범위에 따른 응답 속도를 구간별로 그룹화하여 빈도를 표현하고 있습니다.
저희는 MySQL에 raw 데이터를 저장하고 있고 시간당 많게는 40만건 정도의 데이터를 조회하여 빈도를 계산하여야 합니다.
이를 실시간으로 조회 하기에는 시간의 제약으로 사실상 사용이 불가능한 수준 이였습니다.

이를 개선하고자 현재는 30분 단위로 조회 범위를 지정하고 배치를 이용하여 데어터를 집계하여 집계 데이터를 생성 후 조회를 하고 있습니다.
집계가 완료된 데이터를 조회하기에 시간적 제약은 벗어 났지만 30분마다 데이터를 집계하기에 선형 공간 사용으로 인한 문제가 현재도 발생하고 있습니다.
따라서 선형 공간을 가질 여유가 우리에겐 없기에 이를 준선형 공간으로 바꿀 필요가 있습니다.

# 준선형(Sublinear)

이러한 문제에 대한 솔루션은 준선형(sublinear) 알고리즘을 사용하는 것입니다.

여기서 이야기하는 준선형(sublinear) 공간은 무엇일까요?
sketch에 대한 이해를 하려면 먼저 준선형의 의미를 알필요가 있습니다.

![count-min-sketch-01.jpg](https://young-hwang.github.io/docs/algorithm/images/count-min-sketch-01.jpg)

위의 이미지를 보면 데이터의 증가함에 따라 공간 즉 메모리의 소비도 같은 방식으로 증가하게 되는 선형 그래프를 볼수 있습니다.
반면 준선형은 선형 처럼 많은 데이터를 소비하지는 않지만 그와 비슷한 결과를 나타낼수 있습니다.

준선형(sublinear) 알고리즘을 사용 시 데이터를 압축하여 작은 공간에 저장하므로 데이터 손실이 있을 수 있습니다.
즉 약간의 부정확성이 발생합니다.

준선형으로 변경을 위한 쉽게 떠올릴수 있는 방법으로 Hash table와 Sampling등이 있을 것입니다.
Hash table 의 유일한 단점은 매우 드문경우로 해시 충돌로 모든 빈도를 재계산 하여야 하는 경우가 발생 할수 있다는 것입니다.

![count-min-sketch-00.jpg](https://young-hwang.github.io/docs/algorithm/images/count-min-sketch-00.jpg)

Sampling을 사용할 경우 우리가 얻을 수 있는 스트림은 특정기간이나 확률적이거나 무작위로 샘플링하여 빈도를 측정할 수도 있습니다. 하지만 샘플링이 진정한 임의성을 보장할 수 없고 샘플링 방법에 따라 빈도의 집계가 다를 것입니다.
따라서 이 또한 우리가 원하는 진정한 빈도의 집계에는 부족하다고 볼수 있습니다.

# Count-Min Sketch

그렇다면 이제 왜 CM Sketch 인지. 어떻게 알고리즘이 동작하는지 알아보도록 하겠습니다.
CM Sketch는 2차원의 행열 또는 배열 형태를 가집니다.
Row는 우리가 사용할 해시함수의 수 입니다. 해시 함수의 수는 우리가 지정할 수 있습니다.
더 정확한 값을 원하는 경우 더 많은 해시 함수를 사용 할 수 있습니다.
아래의 예에서는 단순함을 위해 4개의 해시 함수를 사용 할 것입니다.
Col은 해시 함수를 통해 출력하는 최대수는 CM Sketch에서 미리 정의 된 크기내에서 표현하게 됩니다.
이러한 데이터 구조로 CM-Sketch는 준선형(SubLinear)이라고할 수 있습니다.

![count-min-sketch-03.png](https://young-hwang.github.io/docs/algorithm/images/count-min-sketch-03.png)

앞에서 사용하였던 예제를 CM Sketch를 이용하여 표현해 보겠습니다.
지금은 단순히 알파벳을 사용하였지만 실제로는 문장이나 숫자 등 여러가지 값이 될 수 있을 것입니다.

```javascript
[A, B, B, N, A, R, E, A, R, A, B]
```

각 알파벳을 각 해시 함수를 통과 시켜 값을 얻습니다.
A를 예로 들면 h1(A) = 1, h2(A) = 3, h3(A) = 4, h4(A) = 6 으로 나타납니다.
그외 다른 값들도 값을 구하면 아래 테이블과 같습니다.

|   | h1 | h2 | h3 | h4 |
|:---:|:---:|:---:|:---:|:---:|
| A | 1 | 3 | 4 | 6 |
| B | 2 | 1 | 6 | 3 |
| E | 4 | 6 | 4 | 0 |
| N | 6 | 4 | 1 | 2 |
| R | 0 | 2 | 0 | 4 |

이제 CM Sketch의 2차원 배열에 해시 함수에 의해 도출 된 값을 집계하여 보겠습니다.
A를 예로 들면 h1(A) = 1, h2(A) = 3, h3(A) = 4, h4(A) = 6 이므로 h1 row 에서는 col = 1 인 위치에 카운트 하나를 증가 시킵니다.
h2 row 는 col = 3 인 위치에 카운트를 하나 증가 시킵니다.
h3 row 는 col = 4 인 위치에 카운트를 하나 증가 시킵니다.
h4 row 는 col = 6 인 위치에 카운트를 하나 증가 시킵니다.
같은 방법으로 알파벳 스트림의 모든 값을 하나씩 맵핑한다면 결과는 다음과 같습니다.

|   | 0 | 1 | 2 | 3 | 4 | 5 | 6 |
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| h1 | 2 | 4 | 3 | 0 | 1 | 0 | 1 |
| h2 | 0 | 3 | 2 | 4 | 1 | 0 | 1 |
| h3 | 2 | 1 | 0 | 0 | 5 | 0 | 3 |
| h4 | 1 | 0 | 1 | 3 | 2 | 0 | 4 |

우리가 이제부터 하고 싶은 일은 값의 빈도를 확인하는 일입니다.
이미 이전에 스트림 데이터의 각 값에 대하여 해시함수의 값을 알고 있기에 이를 활용하여 값을 확인할 수 있습니다.
예를 들어 'A'의 빈도를 확인하고 싶다면 h1(A) = 1, h2(A) = 3, h3(A) = 4, h4(A) = 6 이기에 해당 위치의 값을 활용하여 sketch 배열에서 위치를 찾아 빈도 값을 확인 합니다.

```javascript
A 의 각 해시 함수에 따른 빈도 결과
h1: 4
h2: 4
h3: 5
h4: 4
```

이렇게 얻어진 빈도수는 4, 4, 5, 4로 알고리즘 이름에서 암시하듯이 이중에서 가장 작은 값 4를 취하게 됩니다.
우리는 모든 데이터를 sketch 배열 내에서 로드하여 빈도를 증가 시켰기에 해시 충돌이 발생하여 값을 증가 시킬수 있기 때문입니다.
따라서 CM Sketch는 확율적 데이터 구조라고할 수 있습니다.

# 우리의 고민 짚어보기

IMQA의 고민사항인 히트맵 차트를 표현함에 있어문제가 되었던 내용을 다시 상기시켜보겠습니다.

![count-min-sketch-02.png](https://young-hwang.github.io/docs/algorithm/images/count-min-sketch-02.png)

위의 이미지를 x축 기준을 살펴보면 1분 단위로 표현이 되고 있는 것을 확인할 수 있습니다.
y축으로는 응답 속도를 작은 단위로 그룹핑하여 빈도수를 측정하여 표현합니다.
즉 우리는 CM Sketch를 이용하여 분단위의 저장공간을 생성하여 측정되어진 응답속도를 그룹핑된 대표값을 이용하여 빈도수를 측정한다면 기존의 데이터를 준선형(sublinear)하게 변경이 가능할 것입니다.

예를들어 2023.07.06 13:01에 네이티브 응답 속도 1436ms이 수집되었다고 가정해보겠습니다.
CM Sketch 저장 공간을 일시(2023.07.06 13:01)를 이용하여 구분되게 생성합니다.
그리고 응답 속도는 1436ms는 5ms단위로 그룹핑을 한다고 하면 1435~1440ms의 범위에 속하므로 1435ms를 대표값으로 빈도수를 증가 시키도록 하는 것입니다.

이걸 어떻게 구현을할 것인가의 문제가 남게 되었습니다.

# RedisBloom

IMQA의 아키텍처상에는 Redis가 시스템의 속도 증가를 위한 캐시의 역할로 주로 사용되고 있습니다.
따라서 이를 활용하여 쉽게 적용을 해보고자 하였습니다.

Redis에는 RedisBloom(https://github.com/RedisBloom/RedisBloom)이라는 오픈소스 확장 모듈이 존재합니다.
이 모듈은 확률적 데이터 구조를 지원하는 기능을 가지는데 Bloom Filter, Cuckoo Filter, Count-Min Sketch, Top-K, t-digest 가 해당 됩니다.
이를 활용한다면 Count-Min Sketch를 구현할 필요없이 간단히 사용이 가능합니다.
하지만 이건 모듈이여서 구성시 모듈 설치가 필요합니다.

# Redis Stack 활용

Redis에서는 Redis Stack을 제공하고 있습니다.
Redis Stack은 Redis 를 기반으로한 응용 프로그램을 구성하기 위한 프레임워크로 Redis와 Redis Modules를 사용하여 응용 프로그램을 쉽게 구성할 수 있게 도와줍니다.
즉 따로 구성을 추가할 필요가 없습니다.
도커를 이용하여 간단히 실행 후 CM Sketch를 이용하여 히트맵 데이터를 생성 및 조회하여 보겠습니다.

```
// docker-compose
version : "3"
services :
  redis:
    container_name: redis_container
    image: redis/redis-stack:latest
    volumes:
      - /Users/id_young/project/IMQA/redis-data:/data
      # redis data 파일이 실제로 저장될 경로 지정
    restart: always
    ports:
      - '6379:6379'
    environment:
      - REDIS_ARGS=--requirepass password
```

```bash
// 일시를 키로 하고 에러율 0.1%, 확실성 99.8%를 가지는 저장소 지정
> CMS.INITBYPROB 202307061301 0.001 0.002
OK

// native 로딩 속도가 1435~1440ms 인 빈도수 1 증가
> CMS.INcrby 202307061301 native:1435 1
1) (integer) 1

// 한번더 증가
> CMS.INcrby 202307061301 native:1435 1
1) (integer) 1

// natvie 로딩 속도 1435~1440ms 조회
> CMS.QUERY 202307061301 native:1435
1) (integer) 2
```

Redis Stack을 활용하여 간단히 CM Sketch 저장소를 만들고 빈도수를 측정해볼 수 있었습니다.

# 결론

지금까지 빈도수 측정을 위한 다양한 방법들고 이를 효율적으로 처리할 CM Sketch에 대하여 이야기 해보았습니다.
그리고 redis stack을 이용하여 CM Sketch 사용도 간단히 해보았습니다.
아직 실무에 적용된 상태도 아니고 적용시 또 다른 많은 고려사항도 필요해 보입니다.
하지만 IMQA가 더욱 빠르고 안정적인 시스템이 되기위해 꼭 필요한 알고리즘이라는 것을 확인할 수 있었습니다.
부족한 글이지만 보시는 분들에게 조금이라도 도움이 되었길 바랍니다. 감사합니다.

















# 소개

# 사전 준비

# Count-Min Sketch

Count-Min(CM) Sketch에 대하여 소개하겠다.
Point Query의 응답에 사용되는 두가지 기본 작업의 이름을 따서 명명 되었으며, 이는 먼저 counting하고 다음으로 최소값을 계산하는 것 입니다.
$e$를 사용하여 자연 로그 함수(ln)를 표현합니다.


# CM Sketch를 이용한 쿼리

## Point Query

## Inner Product Query

## Range Query

# CM Sketch의 응용

# Sketch 기법의 비교

# 결론

# 참고

$e$ : Euler's number. 수학의 상수. 대략 2.71828로 표현

natural logarithm: 수학 상수 $e$ 를 밑으로 하는 로그 함수. e.g. $ln 7.5 = 2.0149..$ 왜냐하면 $e^{2.0149}\dots = 7.5$ 이기 때문이다.

$\epsilon$ : 0에 가까운 양을 나타내는 기호

$1/\epsilon$ : $\epsilon$의 역수. $\epsilon$이 작아지면 $1/\epsilon$ 이 아주 큰 수가 된다. ex) $\epsilon$ = 0.1, $1/\epsilon$ = 10

$\omega =\lceil \frac{e}{\epsilon} \rceil$ :  $\epsilon$는 Count-Min 스케치의 오차 범위를 나타내는 파라미터이며, e는 자연 상수 (약 2.71828...)입니다. 즉, ω는 e를 ε로 나눈 값을 올림한 결과를 나타냅니다. 이 값은 Count-Min 스케치의 파라미터 설정과 관련하여 사용될 수 있습니다.

$d = \lceil ln(\frac{1}{\delta})\rceil$ : $\delta$는 Count-Min 스케치의 확률적 보장 수준을 나타내는 파라미터이며, ln은 자연 로그 함수입니다. 즉, d는 ln(1/δ)를 올림한 결과를 나타냅니다. 이 값은 Count-Min 스케치의 파라미터 설정과 관련하여 사용될 수 있습니다.

Chebyshev inequality(체비 쇼프 부등식)
