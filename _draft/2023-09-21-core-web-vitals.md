---
title: "Core Web Vitals"
last_modified_at: 2023-09-21T00:00-00:00
categories:
- performance
tags:
- web
- web vitals
toc: true
toc_sticky: true
---
# APM

애플리케이션 성능 모니터링(APM)은 소프트웨어 도구와 원격 측정 데이터를 사용하여 비즈니스 크리티컬 애플리케이션의 성능을 
모니터링하는 프로세스입니다. 
기업은 기대되는 서비스 수준을 유지하여 고객이 긍정적인 애플리케이션 경험을 제공받을 수 있도록 노력합니다. 
이들은 APM 도구를 사용하여 애플리케이션의 성능에 대한 실시간 데이터와 인사이트를 제공합니다. 
그러면 IT 팀, DevOps 및 사이트 신뢰성 엔지니어가 애플리케이션의 문제를 신속하게 파악하고 문제를 해결할 수 있습니다.

애플리케이션 성능 모니터링에서는 어떤 지표를 추적하나요?
애플리케이션 성능 모니터링(APM)은 다음과 같은 일반적인 지표를 추적합니다.

CPU 사용량
APM 솔루션은 CPU 사용량 및 메모리 요구 사항과 같은 CPU 지표를 모니터링할 수 있습니다. 
이를 통해 애플리케이션이 정상적으로 작동하는 데 필요한 컴퓨팅 리소스를 확보할 수 있습니다.

응답 시간
사용자들은 지연 없이 서비스에 액세스할 수 있을 것으로 기대하기 때문에 기업에게 응답 시간은 매우 중요합니다. 
APM 솔루션은 허용 가능한 기준 성능과 비교하여 응답 시간을 측정하고, 응답 시간이 임계값 미만으로 떨어지면 사용자에게 알립니다.

오류율
APM 소프트웨어는 애플리케이션을 모니터링하여 오류율을 기록하고 보고합니다. 
오류의 예로는 웹 조회가 시간 초과되거나 데이터베이스 조회가 실패하는 경우를 들 수 있습니다. 
APM은 오류율이 사전 정의된 파라미터를 초과할 때(예: 최근 50개 요청 중 5%에서 오류가 발생한 경우) 알림을 제공합니다.

트랜잭션 추적
APM에서 트랜잭션 추적은 애플리케이션에서 수행되는 단일 트랜잭션에 대한 정확한 가시성을 제공합니다. 
트랜잭션 추적에서 캡처되는 정보로는 사용 가능한 함수 호출, 외부 호출, 데이터베이스 호출 등이 있습니다. 트랜잭션 추적은 트랜잭션 요청을 처음부터 끝까지 모니터링합니다.

인스턴스
APM 솔루션은 애플리케이션을 실행 중인 서버 또는 애플리케이션 인스턴스의 수를 모니터링하고 보고할 수 있습니다. 
또한 사용자 수요에 따라 스케일 업 또는 스케일 다운하도록 알릴 수 있습니다.

요청
APM 소프트웨어는 애플리케이션에 수신되는 사용자 요청 수를 모니터링합니다. 
이 소프트웨어는 트래픽을 모니터링하여 이상 징후를 발견할 경우 알림을 보낼 수 있습니다. 예를 들어 예상치 못한 요청 증가, 동일한 사용자가 실행한 많은 수의 요청 또는 비정상적으로 적은 요청 수에 대해 알릴 수 있습니다.

가동 시간
가동 시간은 온라인 서비스를 제공하는 기업에게 매우 중요합니다. 
대부분의 서비스 수준 계약(SLA)에서는 미리 정해진 기간 동안 일정 비율의 가동 중단 시간만 허용합니다. APM은 애플리케이션 가용성을 모니터링하고 서비스 제공업체와 고객이 동의한 수준과 비교합니다.

[APM의 종류](https://stackify.com/top-10-open-source-apm-tools/)



# Web Vitals
웹 성능은 페이지가 로드되는 속도와 페이지가 사용자 입려에 반응하는 정도에 초점을 맞춘 웹 개발의 중요한 측면이다.
성능 향상을 위해 웹사이트를 최적화하면 사용자에게 더 나은 환경을 제공할 수 있다.
더 나은 사용자 환경은 웹사이트의 목표를 달성하는데 큰 도움이 된다.

웹 성능은 틈새 주제처럼 보일 수 있지만 사실은 광범위하면서도 깊이 있는 주제이다.
하나의 분야로서 그 깊이를 고려하면, 웹 성능에 관한 과정은 접근하기 쉬우면서도 유익한 정보를 제공한다.

점점 더 많은 소비자가 디지털 콘텐츠와 서비스를 이용하기 위해 웹에 의존하고 있다.
웹사이트 분석을 보면 이 이야기가 자체 데이터에서 작동하는 것을 볼 수 있다.
소비자의 요구가 그 어느 때보다 까다로워지고 있다.
소지자는 웹사이트를 경험하면 경쟁업체와 비교할 뿐 아니라 매일 사용하는 동급 최고의 서비스와 비교해 여러분을 평가한다.

성과와 비즈니스 성공 간의 관계에 대해 수행된 몇 가지 연구를 요약하고, 속도가 온라인 벤처가 얼마나 성공할 수 있는지에 있어 결정적인 요소 중 하나인 이유ㄹ 설명한다.

![](https://www.whatap.io/ko/blog/16/img/apm_understanding_2.webp)
![Screenshot 2023-11-13 at 09.43.43.png](..%2F..%2F..%2F..%2F..%2Fvar%2Ffolders%2Fhh%2Fgwd31h4s1m764j46hwr19m2m0000gn%2FT%2FTemporaryItems%2FNSIRD_screencaptureui_LdVPAf%2FScreenshot%202023-11-13%20at%2009.43.43.png)

# 실적은 사용자 유지가 중요하다.

성능은 모든 온라인 벤처의 성공에 중요한 역할을 한다.
빠르게 로드되고 사용자 입력에 적시에 응답하는 웹사이트는 로드 속도가 느리고 속도가 느린 웹사이트보다 사용자의 참여를 더 잘 이끌어내고 유지한다.

e.g. BBC 사이트를 로드하는 데 1초가 걸릴 때 마다 10%의 사용자를 더 잃는다는 사실을 발견했다. 

Google에서는 Core Web Vitals 라는 것을 만들어 사용자 중심 성능 측정항목을 정의 하였다.

# 성능의 핵심은 사용자 경험이다.

사용자 경험에서 속도가 중요하다. 
한 [소비자 연구](https://www.ericsson.com/en/press-releases/2016/2/streaming-delays-mentally-taxing-for-smartphone-users-ericsson-mobility-report)에 따르면 페이지 속도 지연으로 인한 스트레스 반응은 공포영화를 보거나 수학적 문제를 해결하는 것과 유사하며, 소매점에서 계산대에서 기다리는 것보다 높았다.

페이지가 로드되기 시할할 때 사용자가 콘텐츠가 표시될 때까지 기다리는 시간이 있다.
이 작업이 완료되기전에는 별다른 사용자 경험이 없다.
빠른 연결에서는 이러한 경험 부족이 잠깐 발생한다.
그러나 연결이 느린 경우 사용자는 더 많은 문제를 경험할 수 있다.

![](https://web.dev/static/learn/performance/why-speed-matters/image/fig-1_856.png?hl=ko)

성능은 좋은 사용자 환경의 기본적인 측면이다.
사이트에서 많은 양의 코드를 제공하면 브라우저는 사용자 데이터 요금제에서 수 메가바이트의 데이터를 사용하여 다운로드 한다.
휴대기기는 cpu 성능과 메모리가 제한되었 있다.
이로 인해 성능 조건이 저하될 수 있으며 사용자의 행동을 알면 사용자가 웹사이트의 악조건을 해결할 수 있다.


웹 바이탈은 웹에서 우수한 사용자 환경을 제공하는 데 필수적인 품질 신호에 관한 통합가이드를 제공하기 위한 Google의 계획(명세)이다.
웹바이탈은 환경을 간소화하고 사이트가 가장 중요한 측정항목인 코어 웹 타이탈에 집중할 수 있도록 돕는 것을 목표로 한다.

# Core Web Vitals

코어 웹 바이탈은 모든 웹페이지에 적용되는 웹 바이탈의 하위 집합으로, 
모든 사이트 소유자가 측정해야 하며 모든 Google 도구에 표시된다.
각 코어 웹 바이탈은 사용자 환경의 고유한 측면을 나타내며, 현장에서 측정 가능하며, 
중요한 사용자 중심 결과의 실제 환경을 반영한다.

코어 웹 바이탈을 구성하는 측정항목은 시간이 지남에 따라 진화한다.
현재 설정은 사용자 환경의 세 가지 측면인 로드, 상호작용, 시각적 안정성에 중점을 두고 있으며 다음 측정항목과 각 기준을 포함한다.

![LCP](https://web.dev/static/articles/vitals/image/largest-contentful-paint-ea2e6ec5569b6.svg?hl=ko)
![FID](https://web.dev/static/articles/vitals/image/first-input-delay-thresho-4329fd6d1129a.svg?hl=ko)
![CLS](https://web.dev/static/articles/vitals/image/cumulative-layout-shift-t-5d49b9b883de4.svg?hl=ko)

LCP(최대 콘텐츠 렌더링 시간): 로드 성능을 측정한다. 페이지가 처음 로드되기 시작한 후 2.5초 이내에 LCP가 발생해야 한다.
FID(최초 입력 반응 시간): 상호 작용을 측정한다. 페이지의 FID 100ms 이하로 유지해야 한다.
CLS(레이아웃 변경 횟수): 시각적 안정성을 측정한다. 페이지의 CLS를 0.1 이하로 유지해야 한다.

**각 측정항목에 대부분의 사용자에게 권장되는 목표에 도달하도록 하려면 모바일과 데스크톱 기기별로 분류된 페이지 로드의 백분위 75 번째 기준을 측정해야 된다.**

# 측정항목 및 기준점

코어 웹 타이탈에는 측정 항목과 각 측정항목의 목표 기준점이 포함되어 있어 개발자가 사이트 환경의 '우수', '개선이 필요한지', '나쁜지' 정성적으로 이해할수 있다.

일반적으로 코어 웹 바이탈 측정항목의 기준점을 선택하는 데 사용되는 접근 방식과 특정 코어 웹 바이탈 측정항목의 기준점이 선택된 방법을 설명한다.

LCP는 인지된 로드 속도를 측정하고 페이지의 주요 컨텐츠가 로드될 가능성이 있을 때 페이지 로드 타임라인의 지점을 표시한다.
FID는 반응성을 측정하고 사용자가 페이이ㅈ와 처음 상호작용하려고 할 때 느끼는 경험을 수치화한다.
CLS는 시각적 안정성을 측정하고 표시되는 페이지 콘텐츠의 예상치 못한 레이아웃 변화의 양을 정량화한다.

측정 항목을 정성적으ㅗㄹ '좋음', '개선이 필요함', '낮음'으로 분류한다.

|                 | 양호        | 낮음        |백분위수|
|:----------------|:----------|:----------|:--|
| 컨텐츠가 포함된 최대 페인트 | 2500ms 이하 | 4000ms 초과 | 75 |
| 최초 입력 반응 시간     | 100ms 이하  | 300ms 초과  | 75 |
| 누적 레이아웃 변경      | 0.1 이하    | 0.25 초과   | 75 |

75번째 백분위수 값은 사이트 페이지 조회 수의 75% 이상이 '좋음'기준을 충족하면 해당 사이트는 해당 측정항목에 대해 '우수한' 실적을 보이는 것으로 분류한다.

반대로 25%이상이 '낮음' 기준점을 충족하면 사이트 성능이 '낮음'으로 분류 된다.

# 코어 웹 바이탈 측정항목 기준점의 기준

코어 웹 바이탈 측정항목의 기준을 설정할 때 먼저 각 기준이 충족해야 하는 기준을 파악했다.
각 측정항목의 기준을 선택하는 데 어떻게 적용되었는지 설명한다.

## 고품질 사용자 경험

주요 목표는 사용자와 사용자 경험 품질에 맞게 최적화이다.

고품질 사용자 환경과 임곗값을 식별하기 위해 인간의 인식과 HCI(Human Computer Interaction) 연구를 살펴본다.

> HCI: 인간과 컴퓨터 간의 상호작용에 대해 연구하여 궁극적으로 사용하기 편리한 시스템을 만들려는 학문
 
이 연구는 단일 고정 임곗값을 사용하며 요약되는 경우도 있지만 기본 연구는 일반적으로 값의 범위로 표현된다.

e.g. 사용자가 포커스를 잃기 전에 일반적으로 대기하는 시간에 관한 연구는 1초로 설명되는 반경, 기본 연구는 실제로 수백 밀리초에서 수 초까지의 범위로 표현된다.

인식 기준은 사용자와 맥락에 따라 다르다는 사실은 집계 및 익명처리된 Chrome 측정항목 데이터를 통해 추가로 확인할 수 있다.
이는 사용자가 페이지 로드를 취소하기 전에 웹페이지에서 콘텐츠가 표시될 때까지 기다리는 시간이 단 한 시간도 없다는 것을 보여준다.
오히려 이 데이터는 원활하고 연속적인 분포를 보여준다.
[웹 바이탈의 과학 이면](https://blog.chromium.org/2020/05/the-science-behind-web-vitals.html)

## 기존 웹 콘텐츠로 달성 가능

사이트 소유자가 '양호' 기준을 충족하도록 사이트를 최적화할 수 있도록 하려면 웹의 기존 콘텐츠에 이러한 기준을 달성할 수 있어야 한다.
현재 출처의 10%이상이 '양호' 기준점을 충족 해야 한다. 잘 최적화된 사이트가 피드 데이터의 가변성으로 인해 잘못 분류되지 않도록 잘 최적화된 콘텐츠가 일관되게 '양호' 기준을 충족한다.

# 백분위수 

전반적인 실적 분류를 위해 페이지 또는 사이트의 모든 방문 수의 75번째 백분위수 값을 사용한다.

1. 백분위수는 페이지 또는 사이트 방문의 대부분의 목표 수준의 성능을 경험했나?
   높은 백분위수 선택이 좋으나 높을 수록 결과 값이 이상점의 양향을 받을 가능성도 높아짐
   불안정한 네트워크 통한 LCP 샘플 지나치게 많아지는 경우 이상점 샘플이 사이트 성능을 결정하지 않도록한다.
2. 선택한 백분위수의 값이 이상점에 지나치게 영향 받으면 안된다.

예를 들어 100회의 방문 사이트에서 95번째 백분위수와 같이 높은 백분위수를 사용하여 사이트의 실적을 평가하는 경우
를 이상점의 영향을 받지 않으려면 5개의 이상점까지만 허용이 된다.
하지만 75번째 백분위수를 사용시 이상점의 영향을 받지 않기까지 25개의 이상점을 허용 할 수 있다. 
그렇다고 하여도 대부분의 사이트 방문(3/4)는 목표 수준의 성능 이상을 경험하기에 적절한 균형을 이루고 있다 할수 있다.

# LCP

## 경험의 질

1초는 종종 사용자가 작업에 집중을 시작하기 전에 기다릴 시간으로 언급된다.
관련 연구를 살펴보면 1초는 대략 수백 밀리초에서 수초에 이르는 값의 범위를 설명하는 근사치이다

일반적으로 인용되는 두가지 출처는 Card et al과 Miller 이다.

> Card et al
> Newell의 통합 인지 이론을 인용하면서 1초 '즉각 응답' 임계값을 정의한다.
> 즉시 응답 이란 약 1초 이내에(0.3초 ~ 3초 사이) 어떤 자극에 대해 이루어져야하는 응답을 의미한다.
> 인지적 고려를 불러일으키는 환경과의 상호 작용은 대략 0.5초 ~ 2-3초 사이의 범위에 있다.

> Miller
> 응답 지연이 2초 이상이고 또 다른 1초 정도의 연장이 가능하면 인간이 기계 통신으로 수행할 수 있고 수행할 작업은 그들의 성격을 심각하게 바꿀것이다.

Card와 Miller의 영구에서 사용자가 초점을 잃을 때까지 기다리는 시간을 약 0.3초에서 3초의 범위로 설명하고 있다.
따라서 First Contentful Paint의 '좋은' 임계값이 1초이고 First Contentful Paint 다음 가장 큰 Contentful Paint발생한다는 것을 고려하면 LCP 임계값 범위를 1~3초로 더욱 제한한다.
기준에 가장 적합한 이범위의 임계값을 선택하기 위해 아래에서는 이러한 후보 임계값의 달성 가능성을 살펴 본다.

## 달성 가능성

최적화가 잘된 사이트에 대하여 LCP 성능을 분석하여 일관되게 달성할 수 있는 임계값을 파악하였다.

'양호' 분류된 CrUX 출처의 비율

        1초	1.5초	2초	2.5초	3초
phone	3.5%	13%	27%	42%	55%
데스크톱	6.9%	19%	36%	51%	64%

실적이 우수한 사이트의 75번째 백분위수에서 일관되게 달성할 수 있는 임곗값을 파악하는 것을 목표로하여 1.5초와 2초 기준점은 일관되게 달성할수 없지만 2.5초는 일관되게 달성할수 있었다.


'불량' 비율

        3초	3.5초	4초	4.5초	5초
phone	45%	35%	26%	20%	15%
데스크톱	36%	26%	19%	14%	10%

4초 기준의 경우 휴대전화 출처의 약 26%, 데스크톱 출체의 21%가 '나쁨'으로 분류된다.
이는 목표 범위인 10~30%에 해당하므로 4초가 '나쁨' 기준점으로 허용된다.

# FID

## 경험의 질

약 100ms의 시각적 피드백 지연은 사용자 입력과 같은 관련 소스에 의해 발생하는 것으로 인식된다.
100ms의 최초 입력 반응 시간 '양호' 기준점이 최소 기준으로 적절할 수 있음을 시사한다. 
입력 처리 지연이 100ms를 초과하면 다른 처리 및 렌더링 단계가 제시간에 완료될 가능성이 없다.

Jakob Nielsen [응답시간: 3가지중요제한](https://www.nngroup.com/articles/response-times-3-important-limits/)에서 사용자가 시스템이 즉시 반응한다고 느낄수 있는 제한으로 0.1초를 정의 하였다.
닐슨은 Michotte의 1962년 인과관계의 인식을 인용한 Miller와 Card를 언급한다

Michotte의 연구에서는 실험 참가자에게 '한 화면에서 두 개의 객체. 객체 A가 출발하여 B를 향해 이동합니다. 
B와 접촉하면 A가 시작되어 A로부터 멀어집니다." Michotte는 객체 A가 중지된 시점과 객체 B가 움직이기 시작하는 시점 간의 시간 간격을 변화시킵니다. Michotte는 최대 약 100ms의 지연 시간에서 참가자가 객체 A가 객체 B의 움직임을 유발한다는 것을 발견했습니다. 약 100밀리초에서 200밀리초 사이의 지연 시간에서는 인과관계에 대한 인식이 혼합되어 있고, 200밀리초 이상의 지연 시간에서는 객체 B의 움직임이 더 이상 객체 A에 의해 발생한 것으로 인식되지 않습니다.
[The psychophysical law of speed estimation in Michotte’s causal events](https://www.sciencedirect.com/science/article/pii/S004269890600352X)
        
최근에는 Kaaresoja등이 [Temporally Perfect Virtual Button](https://dl.acm.org/doi/10.1145/2611387) 조사내용을 공개하였다.
보고서는 터치스크린의 가상 버튼 터치와 다양한 지연 시간에서 버튼이 터치되었음을 나타내는 후속 시각적 피드백 사이의 동시성에 대한 인식에 대한 내용이다.

<=85ms : 시각적 피드백이 버튼 누리가와 동시에 표시된다 인식
<=100ms : 버튼 누리기의 인지된 품질이 높다고 인식
<=150ms : 품질이 저하되었다고 인지
<= 300ms : 매우 낮은 품질로 인지

따라서 임곗값으로 약100ms의 값 범위를 지정하였고 '불량' 임곗값으로 300ms을 지정하였다.

## 달성 가능성

FID 100ms 임계값에 대해 '양호'로 분류된 CrUX 출처의 비율 분석시 웹상의 인기 사이트는 75번째 백분위에서 일관되게 충족 중이다.

      100ms
phone	78%
데스크톱	>99%

# CLS

## 경험의 질

레이아웃 변경 횟수(CLS)는 페이지에 표시되는 콘턴츠가 얼마나 많이 이동하는지 측정하는 새로운 측정항목이다.
CLS가 새로운 기능이므로 이 측정항목의 임곗값을 직접 정할 수 있는 연구는 없다.
따라서 사용자 기대치에 부합하는 임곗값을 식별하기 위해 레이아웃 변경의 양이 다른 실제 페이지를 평가하여 페이지 콘텐츠를 소비할 때 심각한 중단을 일으키기 전에 허용 가능한 최대 변화량을 확인했다.
테스트 결과 0.15 이상에서 변동 수준이 0.1 이상이면 지속적으로 방해가 되는 것으로 인식되는 반명, 0.1 이하의 변동은 눈에 띄지만 크게 지장을 주지 않는 것으로 나타났다.
따라서 레이아웃 변경이 없는 것이 이상적이만 최대 0.1 까지의 값이 '좋은' CLS 임곗값 후보라 결론 내렸다.

## 달성 가능성

'양호'로 분류된 CrUX 출처의 비율(후보 CLS 기준점)

 	    0.05	0.1	0.15
phone	49%	   60%	69%
데스크톱	42%	   59%	69%

CrUX 데이터 기준 0.05가 합리적인 '좋은' 임곗값임을 나타나지만 레이아웃 변경을 방지하기 아려운 사례도 있다.
예를 들어 소셜 미디어 삽입과 같은 서드 파티 삽입 콘텐츠의 경우 삽임된 콘텐츠의 높이는 로드가 완료될 때까지 알 수 없는 경우가 있으며
이로 인해 레이아웃이 0.05보다 크게 변경 될 수 있다.
따라서 많은 출처가 0.05 임곗값을 충족하지만 약간 덜 엄격한 CLS 임곗값 0.1이 경험의 질과 달성 가능성 사이의 균형을 더 잘 맞춘다 결론 지었다.
향후 서드 파티 삽입으로 인해 발생하는 레이아웃 변경을 처리하는 솔루션을 식별하여보다 엄격한 0.05 또는 0을 사용하기를 희망한다.

'저조'로 분류된 CrUX 출처의 비율(후보 CLS 기준점)

 	  0.15	0.2	0.25	0.3
phone	31%	25%	20%	18%
데스크톱	31%	23%	18%	16%

10~30% 에 해당하는 0.25를 '나쁜' 임계값으로 결론지었다.

# LCP(Largest Contentful Pain)

[Load](https://developer.mozilla.org/en-US/docs/Web/API/Window/load_event) or [DOMContentLoaded](https://developer.mozilla.org/en-US/docs/Web/API/Document/DOMContentLoaded_event)와 같은 측정항목은 효과적이지 않다.
사용자 화면에 표시되는 것과 반드시 일치하지는 않기 때문이다.
FCP(First Content Paint - 콘텐츠가 포함된 첫 페인트)와 같은 새로운 사용자 중심 성능 측정항목은 로드 환경의 맨 처음 부분만 포착한다.
페이지에 스플래시 화면이 표시되거나 로드 표시기가 표시디ㅗ는 경우 이 시점은 사용자와 크게 관련이 없다.

이전 초기 페인트 후 더 많은 로드 환경을 캡처하는 데 도움이 되도록 첫 번째 의미 있는 페인트(FMP) 및 속도 색인(SI)와 같은 성능 측정항목을 권장했지만, 이러한 측정항목은 복잡하고 설명하기 어렵고 종종 잘몽되어 페이지의 주요 콘텐츠가 로드된 시점 파악을 못한다.

## LCP란 무엇인가?

최대 콘텐츠 렌더링 시간(LCP)는 페이지가 처음 로드하기 시작한 시점을 기준으로 표시 영역 내에 표시되는 가장 큰 이미지 또는 텍스트 블록의 렌더링 시간을 보고한다.

좋은 LCP 점수란? 최대 콘텐츠 렌더링 시간이 2.5초 이하여야 한다.

### 고려되는 요소는 무엇인가?

- <img> 요소
- <svg> 요소내의 <imgae> 요소
- 포스터 이미지가 있는 <video> 요소(포스터 이미지 로드 시간이 사용됨)
- url() 함소를 통해 로드된 배경 이미지가 있는 요소
- 텍스트 노드 또는 기타 인라인 수준 텍스트 요소 하위 요소를 포함하는 블록 수준 요소
- <video> 요소 자동재생을 위해 채색된 첫 번째 프레임
- 애니메이년 GIF 등 애니메이션 이미지 형식의 첫 번째 프레임

'콘텐츠가 없는' 것으로 보일 수 있는 특정 요소를 제외하기 위한 요소

- 사용자에게 표시되지 않고 불투명도가 0인 요소
- 전체 표시 영역을 덮고, 콘텐츠가 아니 배경으로 간주될 가능성이 높은 요소
- 페이지의 실제 콘텐츠를 반영하지 못하여 엔트로피가 낮은 자리표시자 이미지 또는 기타 이미지

FCP vs LCP 
FCP는 콘텐츠가 하면에 그려질 때, LCP는 기본 콘텐츠가 더 선택적으로 그려질 때를 측정한다.

### 엘리먼트의 크기는 어떻게 결정되나?

최대 콘텐츠 렌더링 시간용으로 보고된 요소의 크기는 일반적으로 표시 영역 내에서 사용자에게 표시되는 크기이다.
요소가 표시 영역 밖에서 확장되거나 요소 중 하나가 잘리거나 보이지 않는 overflow가 있는 경우 해당 부분은 요소의 크기에 포함되지 않는다.

기본 크기에서 크기가 조정된 이미지 요소의 경우 보고되는 크기는 표시 크기 또는 고유 크기 중 더 작은 쪽이다.
예를 들어 이미지가 원래 크기보다 훨씬 작게 축소되면 표시되는 크기만 보고, 더 큰 크기로 늘어나거나 확장된 이미지는 고유 키기만 보고한다.

텍스트의 경우 텍스트 노드의 크기만 고려된다.

CSS를 통해 적용된 여백, 패딩 또는 테두리는 고려하지 않는다.

## LCP가 보고되는 시점은 언제인가?

웹페이지는 종종 단계적으로 로드되므로 페이지에서 가장 큰 요소가 변경될 수 있다.
이러한 변경 가능성을 처리하기 위해 브라우저는 첫 번째 프레임을 그리는 즉시 콘텐츠가 포함된 가장 큰 요소를 식별하는 largest-contentful-paint 유형의 PerformanceEntry를 전달한다.
후속 프레임을 렌더링한 후에는 콘텐츠가 포함된 가장 큰 요소가 변경될 때마다 다른 PerformanceEntry를 전달 한다.

e.g. 텍스트와 히어로 이미지가 있는 페이지에서 처음 텍스트만 렌더링할 수있다. 이때 브라우저는 element 속성이 p 또는 h1 을 참조할 가능성이 있는 lcp 항목으로 전달한다.
나중에 히어로 이미지가 로드가 완료되면 두번째 lcp 항목이 전달되고 img를 참조한다.

요소가 렌더링되고 사용자에게 표시된 후에만 콘텐츠가 포함된 최대 요소로 간주할 수 있다는 점에 유의한다.
아직 로드되지 않은 이미지는 '렌더링된'것으로 간주되지 않는다.

늦게 로드되는 이미지와 글꼴 외에도 페이지에서 새 콘텐츠를 사용할 수 있게 되면 DOM에 새 요소를 추가할 수 있다.
이러한 새 요소중 하나라도 이전의 가장 큰 콘텐츠 요소보다 크면 PerformanceEntry에 보고 된다.

사용자 상호작용으로 인해 사용자에게 표시되는 항목이 변경되는 경우가 많기 때문에(특히 스크롤의 경우) 브라우저에서는 사용자가 탭, 스크롤 또는 키 누름을 통해 페이지와 상호작용하는 즉시 새 항목 보고를 중지한다.

분석을 위해 가장 최근에 전달된 PerformanceEntry만 분석 서비스에 보고한다.

### 로드 시간 및 렌더링 시간 비교

보안상의 이유로 이미지의 렌더링 타임스탬프는 Timing-Allow-Origin 헤더가 없는 교차 출처 이미지에 노출되지 않는다.
대신 로드 시간만 노출된다. 이는 이미 다른 많은 웹 API를 통해 노출되었기 때문이다.

이로 인해 웹 API에서 LCP를 FCP보다 빨리 보고하는 것이 불가능해 보이는 상황이 발생할 수 있다. 보안 제한 때문에 이런일이 발생하는 것은 아니다.

가능하면 항상 Timing-Allow-Origin 헤더를 설정하여 측정항목의 정확성을 높이는 것이 좋다.

### 요소 레이아웃과 크기 변경은 어떻게 처리되나?

새 성능 항목을 계산하고 전달하는 성능 오버헤드를 낮게 유지하기 위해 요소의 크기나 위치를 변경해도 새 LCP 후보가 생성되지 않는다.
표시 영역 내 요소의 초기 크기와 위치만 고려된다.

즉 처음 화면 밖으로 렌더링된 후 화면에서 전환되는 이미지는 보고되지 않을 수 있다.
또한 표시 영역에 처음 렌더링된 요소가 시야에서 아래로 밀려나면 초기 표시 영역 내 크기를 계속 보고한다.

example

![](https://web.dev/static/articles/lcp/image/largest-contentful-paint-fc43128e011aa_856.png?hl=ko)
![](https://web.dev/static/articles/lcp/image/largest-contentful-paint-3713e2f14970a_856.png?hl=ko)

가장 큰 요소는 콘텐츠가 로드될 때 변경된다.
첫 번째 예에서는 DOM에 새 콘텐츠가 추가되어 가장 큰 요소가 변경된다.
두 번째 예에서는 레이아웃이 변경되고 이전에 가장 큰 콘텐츠가 표시영역에서 삭제된다.

![](https://web.dev/static/articles/lcp/image/largest-contentful-paint-9bc403e812154_856.png?hl=ko)
![](https://web.dev/static/articles/lcp/image/largest-contentful-paint-6c5554de0eac7_856.png?hl=ko)

첫 번째 예에서 Instagram 로고는 비교적 일찍 로드되며 다른 콘텐츠가 점직적으로 표시 되더라도 여전히 가장 큰 요소로 유지된다.
Google 검색결과 페이지 예에서 가장 큰 요소는 이미지나 로고의 로드가 완료되기 전에 표시되는 텍스트 단락이다.
모든 개별 이미지는 이 닥락보다 작기 때문에 로드 프로세스 전반에 걸쳐 가장 큰 요소로 유지된다.

### 자바스크립트에서 LCP 측정

```javascript 
new PerformanceObserver((entryList) => {
  for (const entry of entryList.getEntries()) {
    console.log('LCP candidate:', entry.startTime, entry);
  }
}).observe({type: 'largest-contentful-paint', buffered: true});
```

largest-contentful-paint 항목은 현재 LCP 후보를 나타낸다. 
일반적으로 마지막으로 내보낸 항목의 startTime 값이 LCP 값이다. 
그러나 항상 그런 것은 아니다. 
일부 largest-contentful-paint 항목은 LCP 측정에 유효하지 않다.

측정항목과 API의 차이점 
- API는 백그라운드 탭에 로드된 페이지의 largest-contentful-paint 항목을 전달하지만 LCP를 계산할 때 이러한 페이지는 무시해야 한다.
- API는 페이지가 백그라운드로 전환된 후에도 largest-contentful-paint 항목을 계속 전달하지만 LCP를 계산할 때는 이러한 항목을 무시해야 한다. (페이지가 전체 시간 동안 포그라운드에 있는 경우에만 요소 고려).
- API는 페이지가 뒤로-앞으로 캐시에서 복원될 때 largest-contentful-paint 항목을 보고하지 않지만, 사용자가 고유한 페이지 방문으로 경험하므로 이러한 경우 LCP를 측정해야 한다.
- API는 iframe 내의 요소를 고려하지 않지만, 측정항목은 페이지에서 사용자 환경의 일부이므로 이를 고려한다. 
iframe 내에 LCP가 있는 페이지(예: 삽입된 동영상의 포스터 이미지)에서 이는 CrUX와 RUM의 차이로 표시된다. 
LCP를 제대로 측정하려면 이를 고려해야 한다. 
하위 프레임은 API를 사용하여 집계를 위해 largest-contentful-paint 항목을 상위 프레임에 보고할 수 있다.

# CLS

시각적 안정성을 측정하는 중요한 사용자 중심 측정항목이다.
사용자가 예상치 못한 레이아웃 변경을 경험하는 빈도를 수치화하는 데 도움이 되기 때문이다.

![](https://web.dev/static/articles/cls/video/web-dev-assets/layout-instability-api/layout-instability2.webm?hl=ko)

일반적으로 리소스가 비동기식으로 로드되거나 DOM 요소가 기존 콘텐츠 위의 페이지에 동적으로 추가되기 때문에 페이지 콘텐츠의 예기치 않은 이동이 발생한다. 
크기를 알 수 없는 이미지 또는 동영상, 대체 글꼴보다 크거나 작게 렌더링되는 글꼴, 동적으로 크기가 조절되는 서드 파티 광고 또는 위젯이 원인일 수 있다.

이 문제가 더 큰 문제는 개발 중인 사이트의 작동 방식과 사용자가 경험하는 방식과 크게 다른 경우가 많기 때문입니다. 
개인 맞춤 콘텐츠 또는 서드 파티 콘텐츠는 개발 단계에서 프로덕션 환경과 동일한 방식으로 작동하지 않는 경우가 많고, 테스트 이미지가 이미 개발자의 브라우저 캐시에 있는 경우가 많으며, 로컬에서 실행되는 API 호출은 매우 빨라서 지연이 눈에 띄지 않는 경우가 많습니다.

레이아웃 변경 횟수 (CLS) 측정항목은 실제 사용자에게 발생하는 빈도를 측정하여 이 문제를 해결하는 데 도움이 된다.

## CLS란 무엇인가?

페이지의 전체 수명 동안 발생하는 모든 예상치 못한 레이아웃 변경에 관한 레이아웃 변경 점수의 최대 버스트를 측정한 것이다.
레이아웃 변경은 표시되는 요소가 하나의 렌더링된 프레임에서 다음 프레임으로 위치를 변경할 때마다 발생한다.
개별 레이아웃 변경 점수가 계산되는 방식은 아래와 같다.

세션 윈도우라고 하는 레이아웃 변경 버스트는 하나 이상의 개별 레이아웃 변경이 각 이동 간격이 1초미만이고 총 윈도우 지속 시간이 최대 5초인 경우 빠르게 연속으로 발생하는 경우를 말한다.
가장 큰 버스트는 해당 기간 내의 모든 레이아웃 변경의 최대 누적 점수가 있는 세션 기간이다.

![](https://web.dev/static/articles/cls/video/web-dev-assets/better-layout-shift-metric/session-window.webm?hl=ko)

## 좋은 CLS 점수란?

75 백분위수가 0.1 이하가 되도록 하여야 한다.

### 레이아웃 변경 세부정보

레이아웃 변경은 Layout Instability API에 의해 정의 된다.
표시 영역 내에 표시되는 요소가 두 프레임 사이에서 시작 위치를 변경할 때마다 layout-shift 항목을 보고한다.
이러한 요소는 불안정한 요소로 간주한다.

레이아웃 변경은 기존 요소가 시작 위치를 변경할 때만 발생한다.
새 요소가 DOM에 추가되거나 기존 요소의 크기가 변경되면 다른 시각적 요소의 시작 위치가 변경되지 않는 한 레이아웃 변경으로 간주되지 않는다.

### 레이아웃 변경 점수

레이아웃 변경 점수를 계산하기 위해 브라우저는 표시 영역 크기 및 렌더링된 두 프레임사이에서 표시 영역에 있는 불안정한 요소의 이동을 확인한다.
레이아웃 변경 점수는 영향 비율과 거리 비율 이라는 두가지 이동 측정값의 곱이다.

```shell
layout shift score = impact fraction * distance fraction
```

### 영향 비율

영향 비율은 불안정한 요소가 두 프레임 사이의 뷰포트 영역에 미치는 영향을 측정한다.
이전 프레임과 현재 프레임에 대한 모든 불안정 요소의 가시 영역의 결합(뷰포트의 전체 영역의 일부분)은 현재 프레임에 대한 영향 비율이다.

![](https://web.dev/static/articles/cls/image/impact-fraction-example-164341c82ee76_856.png)

위의 이미지에는 한 프레임에서 뷰포트의 절반을 차지하는 요소가 있다. 
다음 프레임에서 요소는 뷰포트 높이의 25%만큼 아래로 이동한다. 
빨간색 점선 직사각형은 두 프레임에서 요소의 가시 영역의 결합을 나타낸다. 
이 경우 전체 뷰포트의 75%이므로 영향 분율은 0.75입니다.

### 거리 비율

layout shift 점수 방정식의 다른 부분은 불안정한 요소가 이동한 거리를 뷰포트를 기준으로 측정한다. 
거리 비율은 프레임(수평 또는 수직)에서 불안정한 요소가 이동한 최대 거리를 뷰포트의 최대 치수(폭 또는 높이 중 더 큰 것)로 나눈 값입니다.

![](https://web.dev/static/articles/cls/image/distance-fraction-example-9146d2a862482_856.png)

위의 예에서 가장 큰 뷰포트 치수는 높이이며 불안정한 요소는 뷰포트 높이의 25%만큼 이동하여 거리 분율이 0.25가 됩니다.

따라서 이 예제에서는 충격 분율이 0.75이고 거리 분율이 0.25이므로 레이아웃 이동 점수는 0.75 * 0.25 = 0. 1875입니다.

초기에 layout shift 점수는 충격 분율만을 기반으로 계산되었습니다. 
거리 분율은 큰 요소가 적은 양만큼 이동하는 경우를 과도하게 불이익을 주는 것을 피하기 위해 도입되었습니다.

다음 예제에서는 기존 요소에 컨텐츠를 추가하면 레이아웃 이동 점수에 어떤 영향을 미치는지 보여 준다.

![](https://web.dev/static/articles/cls/image/layout-shift-example-mul-10d90b67b5d6a_856.png)

"클릭!" 버튼은 흰색 텍스트가 포함된 녹색 상자를 아래로 밀어내고 부분적으로 뷰포트 밖으로 내립니다.
이 예제에서 회색 상자의 크기는 변경되지만 시작 위치는 변경되지 않으므로 불안정한 요소는 아닙니다.
"클릭 미!" 버튼은 이전에 DOM에 없었기 때문에 시작 위치도 변경되지 않습니다.
그러나 그린 박스의 시작 위치는 변경되지만 뷰포트 밖으로 부분적으로 이동되었기 때문에 충돌 분율을 계산할 때 보이지 않는 영역은 고려되지 않습니다. 두 프레임(빨간색 점선 직사각형으로 표시됨)에서 그린 박스에 대한 가시 영역의 합은 첫 프레임의 그린 박스 면적(뷰포트의 50%)과 동일합니다. 충돌 분율은 0.5입니다.
거리 분율은 보라색 화살표로 표시됩니다. 녹색 상자는 뷰포트의 약 14%만큼 아래로 이동하여 거리 분율은 0.14입니다.
레이아웃 이동 점수는 0.5 x 0.14 = 0.07입니다.

이 마지막 예는 여러 불안정 요소를 보여 줍니다

![](https://web.dev/static/articles/cls/image/layout-shift-example-sta-05cf93597fcee_856.png)

위 첫번째 프레임에는 동물용 API 요청 결과 4가지가 알파벳순으로 정렬되어 있으며, 두번째 프레임에는 정렬된 목록에 더 많은 결과가 추가됩니다.
목록의 첫 번째 항목("Cat")은 프레임 간 시작 위치가 변경되지 않으므로 안정적입니다. 마찬가지로 목록에 새로 추가된 항목은 이전에 DOM에 없었기 때문에 시작 위치도 변경되지 않습니다. 하지만 "Dog", "Horse", "Zebra"로 표시된 항목은 모두 시작 위치가 변경되어 불안정한 요소입니다.
다시 빨간색 점선 직사각형은 이 세 불안정 요소의 전후 영역의 결합을 나타냅니다. 이 경우 뷰포트 면적의 약 60%(충격 분율 0.60)입니다.
화살표는 불안정한 요소가 시작 위치에서 이동한 거리를 나타냅니다. 파란색 화살표로 표시되는 "Zebra" 요소는 뷰포트 높이의 약 30%만큼 가장 많이 이동했습니다. 이 예에서 거리 분율은 0.3입니다.
레이아웃 이동 점수는 0.60 x 0.3 = 0.18입니다.

### 예상 레이아웃 이동 대 예상 레이아웃 이동

모든 레이아웃 이동이 나쁜 것은 아닙니다. 실제로 많은 동적 웹 응용 프로그램은 페이지의 요소 시작 위치를 자주 변경합니다.

- 사용자 시작 레이아웃 이동
 
레이아웃 시프트는 사용자가 기대하지 않는 경우에만 좋지 않다. 
반면, 사용자 상호 작용(링크 클릭, 버튼 누르기, 검색 상자 입력 등)에 반응하여 발생하는 레이아웃 시프트는 사용자에게 명확한 상호 작용에 충분히 가까운 상태에서 발생하는 한 일반적으로 괜찮습니다.
예를 들어, 사용자 상호 작용이 완료하는 데 시간이 걸릴 수 있는 네트워크 요청을 트리거하는 경우, 요청이 완료될 때 불쾌한 레이아웃 변경을 피하기 위해 바로 공간을 만들고 로드 표시기를 표시하는 것이 가장 좋습니다. 
사용자가 무언가가 로드되고 있다는 것을 깨닫지 못하거나 리소스가 언제 준비될지 모르는 경우, 대기 중에 다른 것(그 아래에서 이동할 수 있는 것)을 클릭하려고 시도할 수 있습니다.
사용자 입력 후 500밀리초 이내에 발생하는 레이아웃 이동에는 hadRecentInput 플래그가 설정되므로 계산에서 제외할 수 있습니다.

- animation과 transition

애니메이션과 전환은 잘 이루어졌을 때 사용자를 놀라게 하지 않고 페이지의 콘텐츠를 업데이트할 수 있는 좋은 방법입니다. 
페이지에서 갑자기 갑자기 이동하는 콘텐츠는 거의 항상 나쁜 사용자 경험을 생성합니다. 
그러나 한 위치에서 다음 위치로 점진적으로 자연스럽게 이동하는 콘텐츠는 종종 사용자가 무슨 일이 일어나고 있는지 더 잘 이해하고 상태 변화 사이에서 안내할 수 있습니다.
일부 사이트 방문자는 애니메이션으로 인한 부작용이나 주의 집중 문제를 경험할 수 있으므로 우선순위 감소-모션 브라우저 설정을 준수해야 합니다.
CSS 변환 속성을 사용하면 레이아웃 이동을 트리거하지 않고도 요소를 애니메이션화할 수 있습니다:
높이 및 너비 속성을 변경하는 대신 변환: scale()을 사용합니다.
요소를 이동하려면 상단, 오른쪽, 하단 또는 왼쪽 속성을 변경하지 말고 transform: translate()를 대신 사용합니다.

### 자바스크립트에서 레이아웃 변경 측정

자바스크립트에서 레이아웃 변경을 측정하려면 Layout Instability API를 사용합니다.

다음 예에서는 layout-shift 항목을 콘솔에 로깅하는 PerformanceObserver를 만드는 방법을 보여줍니다.

```javascript 
new PerformanceObserver((entryList) => {
   for (const entry of entryList.getEntries()) {
      console.log('Layout shift:', entry);
   }
}).observe({type: 'layout-shift', buffered: true});
```

# FID(First Input Delay)

응답하지 않는 페이지와 상호 작용을 시도할 때 사용자가 느끼는 경험을 수치화하기 때문에 로드 응답성을 측정하기 위한 안정적인 코어  웁 바이탈 메트릭으로 FID가 낮으면 페이지를 사용할 수 있도록 보장한다.
FID는 2024년 3월 INP(Interaction to Next Paint)로 대체될 예정이다.

좋은 첫인상을 만드는 것이 얼마나 중요한지 우리 모두는 잘 알고 있습니다. 
웹에서 좋은 첫인상은 누군가가 충성스러운 사용자가 되는 것과 떠났다가 다시 돌아오지 않는 것 사이의 차이를 만들 수 있습니다. 
문제는 무엇이 좋은 인상을 만드는가 하는 것이며 사용자에게 어떤 인상을 줄 가능성이 있는지 어떻게 측정하느냐 하는 것입니다?
웹에서 첫인상은 다양한 형태로 나타날 수 있습니다. 
사이트의 디자인과 시각적인 매력에 대한 첫인상과 속도와 반응성에 대한 첫인상이 있습니다.

웹 API로 사용자들이 사이트의 디자인을 얼마나 좋아하는지 측정하는 것은 어렵지만, 그것의 속도와 반응성을 측정하는 것은 그렇지 않습니다!
FCP(First Contentful Paint)를 사용하여 사이트 로드를 얼마나 빨리 측정할 수 있는지에 대한 첫인상을 사용자는 알 수 있습니다. 
그러나 사이트가 화면에 픽셀을 얼마나 빨리 그릴 수 있는지는 이야기의 일부일 뿐입니다. 
마찬가지로 중요한 것은 사용자가 픽셀과 상호 작용하려고 할 때 사이트가 얼마나 반응하는지에 대한 것입니다!
FID(First Input Delay) 메트릭은 사이트의 상호작용성 및 반응성에 대한 사용자의 첫인상을 측정하는 데 도움이 됩니다.

FID는 이벤트 처리의 "지연"만 측정합니다. 
이벤트 처리 시간 자체나 이벤트 핸들러를 실행한 후 브라우저가 UI를 업데이트하는 데 걸리는 시간을 측정하지는 않습니다. 
이 시간은 사용자 경험에 영향을 미치지만 FID의 일부로 포함되면 개발자가 이벤트에 비동기적으로 응답하도록 유도하므로 메트릭이 향상되지만 경험이 더 악화될 가능성이 있습니다. 
자세한 내용은 아래의 입력 지연만 고려하는 이유를 참조하십시오.

일반적인 웹 페이지 로드의 다음 타임라인을 고려합니다
![](https://web.dev/static/articles/fid/image/example-page-load-trace-17c294b2957b6.svg)

위의 시각화는 몇 개의 리소스(대부분 CSS 및 JS 파일)에 대한 네트워크 요청을 수행하는 페이지를 보여주며, 해당 리소스 다운로드가 완료된 후에는 메인 스레드에서 처리됩니다.

그러면 베이지색 작업 블록으로 표시되는 주 스레드가 일시적으로 사용 중인 기간이 발생합니다.

페이지가 일부 내용을 렌더링했지만 아직 신뢰할 수 있는 대화형이 아니기 때문에 FCP(First Contentful Paint)와 TTI(Time to Interactive) 사이에 긴 첫 입력 지연이 발생합니다. 이를 설명하기 위해 FCP와 TTI가 타임라인에 추가되었습니다:

![](https://web.dev/static/articles/fid/image/example-page-load-trace-51d71647fee2c.svg)

FCP와 TTI(Time to Interactive) 사이에 상당한 시간(세 가지 긴 작업 포함)이 있다는 것을 알고 있었을 수도 있습니다. 
사용자가 해당 시간 동안 페이지와 상호 작용을 시도할 경우(예: 링크 클릭) 클릭이 수신될 때와 메인 스레드가 응답할 수 있는 시간 사이에 지연이 발생합니다.

사용자가 가장 긴 작업의 시작 부근에서 페이지와 상호 작용을 시도할 경우 발생할 일을 고려합니다:

![](https://web.dev/static/articles/fid/image/example-page-load-trace-461807023519a.svg)

브라우저가 작업을 실행하는 중에 입력이 발생하기 때문에 작업이 완료될 때까지 기다려야 입력에 응답할 수 있습니다. 
이 페이지에서 이 사용자의 FID 값을 기다려야 합니다.

이 예에서 사용자는 메인 스레드의 가장 바쁜 기간이 시작될 때 페이지와 우연히 상호 작용했다. 
사용자가 유휴 기간 중에 페이지와 조금만 더 일찍 상호 작용했다면 브라우저는 즉시 응답할 수 있었을 것이다. 
입력 지연의 이러한 차이는 메트릭을 보고할 때 FID 값의 분포를 살펴보는 것의 중요성을 강조한다. 
FID 데이터에 대한 분석 및 보고에 대한 아래 섹션에서 이에 대한 자세한 내용을 읽을 수 있다.

### 상호작용에 이벤트 수신기가 없으면 어떻게 합니까?
FID는 입력 이벤트가 수신될 때와 메인 스레드가 다음에 유휴 상태가 될 때 사이의 델타를 측정합니다. 
이는 이벤트 수신기가 등록되지 않은 경우에도 FID를 측정한다는 것을 의미합니다. 
그 이유는 많은 사용자 인터렉션이 이벤트 수신기를 필요로 하지 않고 실행하기 위해 메인 스레드가 유휴 상태가 되어야 하기 때문입니다.
예를 들어, 다음 HTML 요소는 사용자 상호 작용에 응답하기 전에 기본 스레드에서 진행 중인 작업이 완료될 때까지 기다려야 합니다:

텍스트 필드, 확인란 및 라디오 버튼(<input>, <textarea>)
드롭다운 선택(<select>)
링크(<a>)

### 첫 번째 입력만 고려해야 하는 이유는 무엇입니까?
입력이 지연되면 사용자 환경이 나빠질 수 있지만 몇 가지 이유로 첫 번째 입력 지연을 측정하는 것이 좋다.

첫번째 입력 지연은 사용자의 사이트 반응성에 대한 첫 번째 인상이며, 첫 번째 인상은 사이트의 품질과 신뢰성에 대한 전반적인 인상을 형성하는 데 매우 중요하다.
오늘날 웹상에서 볼 수 있는 가장 큰 상호작용성 문제는 페이지 로드 중에 발생하기 때문에 사이트의 첫 번째 사용자 상호작용을 개선하는 데 초기에 집중하는 것이 웹의 전반적인 상호작용성을 개선하는 데 가장 큰 영향을 미칠 것으로 생각한다.
사이트에서 높은 첫 입력 지연(코드 분할, 자바스크립트 미리 로드 감소 등)을 해결하는 방법에 대해 권장하는 솔루션은 페이지 로드 후 느린 입력 지연을 해결하는 방법과 동일한 솔루션은 아닙니다. 
이러한 메트릭을 분리하여 웹 개발자에게 보다 구체적인 성능 지침을 제공할 수 있습니다.

### 첫 번째 입력으로 간주되는 것은 무엇입니까?

FID는 로드 중 페이지의 응답성을 측정하는 메트릭으로 클릭, 탭 및 키 누름과 같은 개별 동작의 입력 이벤트에만 초점을 맞춘다.
스크롤 및 확대/축소와 같은 다른 상호 작용은 연속적인 동작이며 성능 제약이 완전히 다르다. 
브라우저는 별도의 스레드에서 실행하여 지연 시간을 숨길 수도 있다.
즉, RAIL 성능 모델에서 FID는 R(responsibility)에 초점을 맞춘 반면, 스크롤 및 줌잉은 A(애니메이션)와 더 관련이 있으므로 성능 특성을 별도로 평가해야 합니다.

### 사용자가 사이트와 상호 작용하지 않는 경우에는 어떻게 합니까?

모든 사용자가 방문할 때마다 사이트와 상호 작용하는 것은 아닙니다. 
또한 모든 상호 작용이 FID와 관련이 있는 것은 아닙니다(앞 절에서 언급한 바와 같이). 
또한 일부 사용자의 첫 상호 작용은 좋지 않은 시기(메인 스레드가 장시간 사용 중인 경우)에 있고, 일부 사용자의 첫 상호 작용은 좋은 시기(메인 스레드가 완전히 유휴 상태인 경우)에 있을 것입니다.
즉, 일부 사용자는 FID 값이 없고, 일부 사용자는 FID 값이 낮으며, 일부 사용자는 FID 값이 높을 수 있다.
FID를 추적, 보고 및 분석하는 방법은 익숙할 수 있는 다른 메트릭과 상당히 다를 수 있다. 

### 입력 지연만 고려해야 하는 이유는 무엇입니까?

상술한 바와 같이 FID는 이벤트 처리에서의 "지연"만을 측정할 뿐, 이벤트 처리 시간 자체를 측정하지 않으며, 이벤트 핸들러를 실행한 후 브라우저가 UI를 업데이트하는 데 걸리는 시간을 측정하지 않습니다.
이 시간은 사용자에게 중요하고 경험에 영향을 미치지만, 개발자가 실제로 경험을 악화시키는 해결책을 추가하도록 동기를 부여할 수 있기 때문에 이 메트릭에 포함되지 않습니다. 
즉, 이벤트와 관련된 작업과 분리하기 위해 이벤트 핸들러 로직을 비동기 콜백(setTimeout())으로 랩핑하거나 AnimationFrame()을 요청할 수 있습니다. 
그 결과 메트릭 점수는 향상되지만 사용자가 인식하는 응답 속도는 느려집니다.
그러나 FID는 이벤트 지연 시간 중 "지연" 부분만 측정하지만 이벤트 수명 주기를 더 추적하려는 개발자는 이벤트 타이밍 API를 사용하여 이를 수행할 수 있습니다. 
자세한 내용은 사용자 정의 메트릭에 대한 가이드를 참조하십시오.

# Interaction to Next Paint(INP)

INP(Interaction to Next Paint)는 2024년 3월 FID(First Input Delay)를 대체할 보류 중인 코어 웹 바이탈 메트릭입니다. 
INP는 이벤트 타이밍 API의 데이터를 사용하여 응답성을 평가합니다. 
상호 작용으로 인해 페이지가 응답하지 않게 되면 이는 좋지 않은 사용자 경험입니다. 
INP는 사용자가 페이지와 수행한 모든 상호 작용의 지연 시간을 관찰하고 모든(또는 거의 모든) 상호 작용보다 낮은 단일 값을 보고합니다. 
INP가 낮다는 것은 페이지가 모든(또는 대부분) 사용자 상호 작용에 지속적으로 신속하게 응답할 수 있었다는 것을 의미합니다.

크롬 사용 데이터는 페이지에 대한 사용자 시간의 90%가 페이지가 로딩된 후에 사용된다는 것을 보여주기 때문에 페이지 라이프사이클 전체에서 응답성을 신중하게 측정하는 것이 중요하며, INP 메트릭은 이를 평가합니다.
반응성이 좋다는 것은 페이지가 자신과 맺은 상호 작용에 빠르게 반응한다는 것을 의미합니다. 
페이지가 상호 작용에 반응할 때 결과는 시각적 피드백으로 브라우저가 제시하는 다음 프레임에서 브라우저가 제시합니다. 시각적 피드백은 예를 들어 온라인 장바구니에 추가하는 항목이 실제로 추가되고 있는지, 모바일 네비게이션 메뉴가 열렸는지, 로그인 양식의 내용이 서버에 의해 인증되고 있는지 등을 알려줍니다.
일부 상호 작용은 당연히 다른 상호 작용보다 더 오래 걸리지만 특히 복잡한 상호 작용의 경우 사용자에게 어떤 일이 일어나고 있음을 알리는 단서로 초기 시각적 피드백을 신속하게 제공하는 것이 중요합니다. 다음 페인트가 칠될 때까지의 시간이 가장 빠른 기회입니다. 따라서 INP의 의도는 상호 작용의 모든 최종 효과(예: 다른 비동기 작업의 네트워크 가져오기 및 UI 업데이트)를 측정하는 것이 아니라 다음 페인트가 차단되는 시간을 측정하는 것입니다. 시각적 피드백을 지연시킴으로써 사용자에게 페이지가 자신의 작업에 응답하지 않는다는 인상을 줄 수 있습니다.
INP의 목표는 사용자가 수행하는 모든 또는 대부분의 상호 작용에 대해 사용자가 상호 작용을 시작할 때부터 다음 프레임을 칠할 때까지의 시간을 가능한 한 짧게 유지하는 것입니다.
다음의 비디오에서, 오른쪽의 예는 아코디언이 열리고 있다는 즉각적인 시각적 피드백을 제공하고, 사용자가 경험이 깨졌다고 생각하기 때문에 응답성이 얼마나 나쁜지를 또한 보여줍니다.

![](https://web.dev/static/articles/inp/video/jL3OLOhcWUQDnR4XjewLBx4e3PC3/WSmcjiQC4lyLxGoES4dd.mp4)

반응성이 떨어지는 경우와 반응성이 좋은 경우의 예입니다. 
왼쪽에서 긴 작업은 아코디언이 열리지 않도록 차단합니다. 
이로 인해 사용자는 경험이 깨졌다고 생각하고 여러 번 클릭하게 됩니다. 메인 스레드가 따라잡으면 지연된 입력을 처리하여 아코디언이 예기치 않게 열리고 닫힙니다.

이 글은 INP의 작동 방식과 측정 방법을 설명하고 이를 개선하기 위한 자료를 제시합니다.

## INP란 무엇입니까?

INP는 사용자가 페이지를 방문하는 수명 동안 발생하는 모든 클릭, 탭 및 키보드 상호작용의 지연시간을 관찰하여 사용자 상호작용에 대한 페이지의 전반적인 반응성을 평가하는 지표로, 최종 INP 값은 이상치를 무시한 가장 긴 상호작용입니다.

INP 계산 방법에 대한 참고 사항
상호작용은 동일한 논리적 사용자 제스처 동안 발생하는 이벤트 핸들러의 그룹입니다. 예를 들어, 터치스크린 장치의 "탭" 상호작용은 포인터 업, 포인터 다운, 클릭과 같은 여러 이벤트를 포함합니다. 상호작용은 자바스크립트, CSS, 내장 브라우저 컨트롤(폼 요소 등) 또는 이들의 조합에 의해 구동될 수 있습니다.
상호 작용의 지연 시간은 사용자가 상호 작용을 시작할 때부터 시각적 피드백이 있는 다음 프레임이 제공되는 순간까지 상호 작용을 주도하는 이벤트 핸들러 그룹의 가장 긴 단일 기간으로 구성됩니다.

## 좋은 INP 점수는 얼마입니까?
반응성 지표에 "좋음" 또는 "나쁨"과 같은 레이블을 고정하는 것은 어렵습니다. 한편으로는 반응성이 좋은 것을 우선시하는 개발 관행을 장려하고 다른 한편으로는 사람들이 달성 가능한 개발 기대를 설정하기 위해 사용하는 장치의 능력에 상당한 차이가 있다는 사실을 고려해야 합니다.

응답성이 뛰어난 사용자 환경을 제공하기 위해서는 모바일 및 데스크톱 기기에 걸쳐 세분화된 필드에 기록된 페이지 로드의 75번째 백분위수를 측정하는 것이 좋습니다:

INP가 200밀리초 미만이면 페이지의 응답성이 좋다는 것을 의미합니다.
INP가 200밀리초를 초과하거나 500밀리초 미만이면 페이지의 응답성을 개선해야 합니다.
INP가 500밀리초 이상이면 페이지의 응답성이 떨어짐을 의미합니다.


### 상호작용은 무엇인가?

상호작용의 수명. 
이벤트 핸들러가 실행을 시작할 때까지 입력 지연이 발생하며, 이는 메인 스레드의 긴 작업과 같은 요인에 의해 발생할 수 있습니다. 
그러면 상호작용의 이벤트 핸들러가 실행되고, 다음 프레임이 제시되기 전에 지연이 발생합니다.

![](https://web.dev/static/articles/inp/image/a-diagram-depicting-inte-d2bec16a5952.svg)

브라우저가 체크박스, 라디오 버튼, CSS로 구동되는 컨트롤과 같이 자바스크립트로 구동되지 않는 컨트롤을 통해 상호작용성을 제공하기도 하지만 대화성의 주요 동인은 종종 자바스크립트입니다.

INP에 관해서는 다음과 같은 상호작용 유형만 관찰됩니다:

마우스로 클릭.
터치스크린으로 장치를 두드리는 것.
실제 키보드 또는 화면의 키보드에서 키를 누릅니다.

호버링 및 스크롤은 INP에 포함되지 않습니다. 
그러나 키보드(스페이스 바, 페이지 업, 페이지 다운 등)를 사용하여 스크롤하는 경우 키 누름이 포함되어 INP가 측정하는 다른 이벤트를 트리거할 수 있습니다. 
결과적인 스크롤은 INP가 계산되는 방식에 포함되지 않습니다.

상호 작용은 기본 문서 또는 문서에 내장된 iframe에서 발생합니다. 
예를 들어 내장된 동영상에서 재생을 클릭하면 iframe에 무엇이 있는지 최종 사용자가 알 수 없습니다. 
따라서 최상위 페이지에 대한 사용자 경험을 측정하려면 iframe 내 INP가 필요합니다. 
참고로 자바스크립트 웹 API는 iframe 콘텐츠에 접근할 수 없으므로 iframe 내 INP를 측정할 수 없으며 이는 CrUX와 RUM의 차이로 나타납니다.

상호작용은 두 부분으로 구성될 수 있으며, 각각은 여러 개의 이벤트가 있습니다. 
예를 들어 키 입력은 키다운, 키누름 및 키업 이벤트로 구성됩니다. 
탭 상호작용은 포인터 업 및 포인터 다운 이벤트를 포함합니다. 
상호작용 내에서 지속 시간이 가장 긴 이벤트는 상호작용의 지연 시간으로 선택됩니다.

![](https://web.dev/static/articles/inp/image/a-depiction-more-complex-5b1eeba6e5d1.svg)

여러 이벤트 핸들러와의 상호작용을 설명하는 것으로, 
사용자가 마우스 버튼을 클릭하면 첫번째 부분이 입력을 받지만, 
마우스 버튼을 해제하기 전에 프레임이 제시되고, 
사용자가 마우스 버튼을 해제하면 다음 프레임이 제시되기 전에 다른 일련의 이벤트 핸들러가 실행되어야 합니다.

---

참고자료

[](https://blog.chromium.org/2020/05/the-science-behind-web-vitals.html)